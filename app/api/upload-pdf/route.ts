// app/api/upload-pdf/route.ts
import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";
import {
  extractTextFromPdfBuffer,
  parseQuestionsWithGemini,
} from "@/lib/parsePdf";

export const runtime = "nodejs";

function cleanText(input?: string | null): string | null {
  if (!input) return null;
  return input.replace(/\u0000/g, "").replace(/\x00/g, "").trim();
}

export async function POST(req: Request) {
  try {
    const supabase = await createClient();
    const form = await req.formData();
    const file = form.get("file") as File | null;
    if (!file)
      return NextResponse.json({ success: false, message: "No file uploaded" }, { status: 400 });

    const buffer = Buffer.from(await file.arrayBuffer());

    // Upload to Supabase Storage
    const fileName = `uploads/${Date.now()}-${file.name.replace(/\s+/g, "_")}`;
    const { error: uploadErr } = await supabase.storage
      .from("uploads")
      .upload(fileName, buffer, { contentType: file.type });
    if (uploadErr) throw uploadErr;

    const fileUrl = `${process.env.NEXT_PUBLIC_SUPABASE_URL}/storage/v1/object/public/uploads/${fileName}`;
    const { data: user } = await supabase.auth.getUser();
    const uploaderId = user?.user?.id ?? null;

    // 1️⃣ Extract text using Gemini (reads PDF directly)
    const text = await extractTextFromPdfBuffer(buffer);
    if (!text) throw new Error("Failed to extract text from PDF");

    // 2️⃣ Parse questions using Gemini
    const questions = await parseQuestionsWithGemini(text);
    if (!questions.length) throw new Error("No questions parsed by Gemini");

    // 3️⃣ Create Exam
    const title = `Gemini Practice - ${new Date().toLocaleString()}`;
    const { data: examRow, error: examErr } = await supabase
      .from("exams")
      .insert([
        {
          admin_id: uploaderId,
          title,
          description: `Generated by Gemini from ${file.name}`,
          duration_minutes: Math.max(15, questions.length * 2),
          total_marks: questions.length,
          status: "published",
        },
      ])
      .select("id")
      .single();
    if (examErr) throw examErr;
    const examId = examRow.id;

    // 4️⃣ Section
    const { data: secRow, error: secErr } = await supabase
      .from("sections")
      .insert([
        {
          exam_id: examId,
          title: "Gemini Generated Section",
          duration_minutes: Math.max(15, questions.length * 2),
          total_marks: questions.length,
          section_order: 1,
        },
      ])
      .select("id")
      .single();
    if (secErr) throw secErr;
    const sectionId = secRow.id;

    // 5️⃣ Insert Questions + Options
    for (const q of questions) {
      const { data: qRow, error: qErr } = await supabase
        .from("questions")
        .insert([
          {
            section_id: sectionId,
            question_text: cleanText(q.question_text),
            question_type: q.question_type ?? "MCQ",
            marks: q.marks ?? 1,
            negative_marks: 0,
            correct_answer: cleanText(q.correct_answer),
          },
        ])
        .select("id")
        .single();
      if (qErr) throw qErr;

      if (q.options?.length) {
        const payload = q.options.map((opt, i) => ({
          question_id: qRow.id,
          option_text: cleanText(opt.text),
          option_order: i + 1,
          is_correct: !!opt.is_correct,
        }));
        const { error: optErr } = await supabase.from("options").insert(payload);
        if (optErr) throw optErr;
      }
    }

    return NextResponse.json({
      success: true,
      exam_id: examId,
      message: `✅ Gemini created ${questions.length} questions successfully.`,
      file_url: fileUrl,
    });
  } catch (err: any) {
    console.error("upload-pdf error:", err);
    return NextResponse.json(
      { success: false, message: err.message || "Server error" },
      { status: 500 }
    );
  }
}
